
# Chapter00. Summary

프로그래밍 인 스칼라 책을 중점으로 읽으면서 알게 된 것, 다른 언어와 비교점 등을 정리한다.

## 객체 object

### require
`Predef` 독립 객체에 들어 있는 메서드로, preconditioning 을 위해 작성할 수 있다.

## 메서드 method

객체의 멤버인 함수를 메서드라고 부른다.

### 스칼라의 지역 함수
스칼라에선 `private` 을 이용해서 비공개 멤버 메서드를 작성할 수도 있지만. 메서드 안에 메서드를 작성하는 식으로도 `private` 처럼 효과를 나타낼 수 있다.

### 위치 표시자 문법
스칼라에서는 함수 리터럴을 좀 더 간결하게 만들기 위해 밑줄을 하나 이상의 파라미터에 대한 위치 표시자로 사용할 수 있다.

(Go 에서는 선언하고 사용하지 않을 변수/패키지 별칭 등, 파이썬에서는 temp 등으로 사용했던 바로 그 언더바!)

### 부분 적용한 함수
부분 적용 함수는 함수에 필요한 인자를 전부 적용하지 않은 표현식을 말한다. 대신에, 인자를 아무것도 제공하지 않거나 일부만 제공한다.

예를 들면 아래와 같은 코드가 있다.

<pre><code>def sum(a: Int, b: Int, c: Int) = a + b + c
</code></pre>

이렇게 만든 함수를 변수에 저장한다.

<pre><code>val a = sum _
</code></pre>

>호출은 `a(1,2,3)` 과 같이 할 수 있는데 이는 `a.apply(1,2,3)` 과 동일하다.

여기서 `sum` 은 부분 적용 함수가 된다. 왜냐하면 함수를 할당할 때 인자를 모두 넘기지 않았기 때문이다.

만약 `sum(1 ,_: Int, 3)` 와 같이 호출한다면 두 번째 인자는 제공하지 않았으므로 스칼라 컴파일러는 만들어진 함수에 따라 인자를 제공하게 된다.

### 특별한 형태의 함수 호출

#### 반복 파라미터
스칼라에서는 함수의 마지막 파라미터를 반복 해서 쓸 수 있게 지원해준다.

<pre><code>def echo(args: String*) =
  for (arg <- args) println(arg)
</code></pre>

내부적으로 args 는 Array[String] 이 된다. 그러나 그렇다고 해서 해당 타입으로 변수를 생성해서 그대로 넘길 수는 없고, 만약에 해당 타입의 변수를 넘기려면 (Array) 아래와 같이 처리해주어야 한다.

```
val arr = Array("Hello", "World!")
echo(arr: _*)
```

#### 이름 붙인 인자
기존에 메서드에서 인자 값을 주고 호출 할 때는 그 순서가 메서드의 매개변수의 순서와 맞아야 했지만, 이름을 붙여서 호출할 수도 있다. (파이썬이랑 동일!)

```
functionName(arg1=val1, arg2=val2)
```

#### 디폴트 인자
스칼라에서는 파라미터의 디폴트 값을 지정할 수 있다.

```
def functionName(arg: Object = defaultValue) = {...}
```

### 스칼라는 어떻게 배열을 괄호를 사용해 접근할 수 있을까?
정확히는 `apply` 메서드를 호출해서 그렇다.
즉, arr 이라는 배열이 있다고 했을 때 arr(0) 은 arr.apply(0) 과 같다.

스칼라의 이런 원칙은 배열에만 국한된 것은 아니고, 어떤 종류의 객체이든 괄호 안에 인자를 넣으면 `apply` 메서드를 호출하는 것과 같다.

마찬가지로, 어떤 변수 뒤에 괄호로 둘러싼 인자들이 있는 표현식에 할당을 하면 모두 인자로 넣어서 `update` 메서드를 호출한다.

### 스칼라의 메서드 괄호 유무
스칼라에서는 인자를 받지 않고 부수 효과도 없는 메서드는 괄호를 아예 붙이지 않는, 파라미터 없는 메서드로 정의할 것을 권장한다.

한편, 부수 효과가 있다면 필드로 접근하는 것과 동일하게 보일 수 있으므로 괄호를 생략해서는 안된다.

```
"hello".length // 부수 효과가 없으므로 괄호 없음
println() // 괄호가 있는게 더 낫다.
```

## 클로저

주어진 함수 리터럴로부터 실행 시점에 런타임에 만들어낸 객체인 함수 값(객체)을 `클로저` 라고 부른다.
`클로저` 란 이름은 함수 리터럴의 본문에 있는 모든 자유 변수에 대한 바인딩(변수 이름과 스코프상에서 실제 값 또는 변수 위치 등에 대한 연결)을 포획해서 자유 변수가 없게 닫는 행위에서 따온 말이다.

아래의 코드 처럼

<pre><code>val addMore = (x:Int) => x + more
</code></pre>

변수 _more_ 처럼 자유 변수가 있는 것을 `클로저` 라 한다.
실행 시점에 만들어내는 함수 값은 정의에 따라 자유변수인 _more_ 의 바인딩을 포획해야 하기 때문이다.

또한 스칼라의 클로저는 변수가 참조하는 값이 아닌 __변수 자체__ 를 포획한다.

포획한 인자는 스택이 아닌 힙에 있게 된다.

## 커링
함수의 인자 여러개를 추가하는 대신 인자 하나를 갖는 인자 목록을 사용해 호출하는 것을 의미한다.

```
scala> def plainOldSum(x: Int, y: Int) = x + y
plainOldSum: (x: Int, y: Int)Int

scala> plainOldSum(1,2)
res48: Int = 3

scala> def plainNewSum(x: Int)(y: Int) = x + y
plainNewSum: (x: Int)(y: Int)Int

scala> plainNewSum(1)(2)
res49: Int = 3
```

## 제어 구조
```
scala> def twice(op: Double => Double, x: Double) = op(op(x))
scala> twice(_+2, 3)
res53: Double = 7.0
```

여기서 op는 `_+2` 가 되고 x가 3이니까 3+2의 결과 5가 나오고 5+2 해서 7의 결과가 나오는 것 같다.

처음에 들어가는 인자 값은 인풋 Double 에 리턴 Double이 되어야 하므로 구문이 아니라 표현식이 들어가야 한다.

## 클래스
스칼라에서 상속도 자바 처럼 `extends` 키워드를 쓴다. 다만 다른게 있다면 자바에선 `Object` 라는 최상위 클래스가 있고 스칼라에선 `AnyRef` 라는 클래스를 상속 받는다.

>자바와 또 다른 점은 네임스페이스가 2개만 있다는 것이다. 바로 __값__ 과 __타입__ 이다.

## 트레잇 trait
트레잇은 자바의 인터페이스와 유사하지만 원한다면 메서드 정의도 할 수 있다.
