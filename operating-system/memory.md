# 메모리
각 프로세스도 메모리를 사용하고, 커널 자체도 메모리를 사용한다.

## 프로세스 주소 공간
프로세스에서 직접 물리 메모리 주소에 접근하지 않는다. 대신 커널이 개별 프로세스에 독자적인 가상 주소 공간을 제공한다.

### 페이지와 페이징
페이지는 메모리 관리 유닛 (MMU) 에서 관리할 수 있는 최소 단위이다.
가상 주소 공간 (Virtual memory) 는 페이지로 구성되어 있다.

주소 공간의 크기에 따라 수많은 페이지를 담을 수 있다. (백만개 부터 수억개 까지)


## 메모리 전략

#### 메모리 정보
`free` 명령어로 확인할 수 있다.

#### 메모리 부족
메모리 사용량이 증가하면 free 한 메모리 영역이 줄어든다. 그리고 이 영역을 다 사용하게 된다면 메모리 관리 시스템은 커널 내부의 해제 가능한 메모리 영역을 해제한다.
그래도 메모리가 부족하다면 시스템은 `Out Of Memory` 상태가 된다.

이러한 경우 메모리 관리 시스템은 적절한 프로세스를 찾아 강제 종료 `kill` 을 한다. 이를 __OOM Killer__ 라고 한다.

##### 죽일 (...) 프로세스를 찾는 방법
메모리 관리 시스템은 죽이기 가장 좋은 프로세스를 선택한다. 여기서 _좋다_ 라는 의미는 죽였을 때 가장 큰 메모리를 확보할 수 있고 시스템에 큰 영향이 가지 않을 수 있다는 것에 대한 의미이다.

이를 위해 리눅스는 `oom_score` 라는 값을 각 프로세스마다 갖고 있다. 이런식으로 확인 가능하다.

```
$ cat /proc/<pid>/oom_score
```

이 값이 크면 클 수록 죽을 확률이 높다.

[스택오버플로우](https://unix.stackexchange.com/questions/153585/how-does-the-oom-killer-decide-which-process-to-kill-first), [linux_mm](https://linux-mm.org/OOM_Killer)  를 참고하였다.

만약 아주 중요한 프로세스를 메모리 관리 시스템이 kill 하게 된다면, 서비스는 큰 문제가 발생할 것이다. 그래서 리눅스 커널 파라미터 (vm.panic_on_oom) 의 기본값을 변경해 프로세스가 아니라 시스템을 종료하게 만들 수도 있다.


#### 메모리 할당
커널이 프로세스에 메모리를 할당하는 일은 크게 두 가지 타이밍에서 벌어진다.

1. 프로세스를 생성할 때
2. 프로세스를 생성한 뒤 추가로 동적 메모리를 할당할 때

프로세스가 생성된 뒤 추가로 메모리가 더 필요하면 프로세스는 커널에 메모리 확보용 시스템 콜을 호출해서 메모리 할당을 요청한다.
이 때 발생하는 문제점은 다음과 같이 있다.

1. 메모리 단편화
2. 다른 용도의 메모리에 접근 가능
3. 여러 프로세스를 다루기 곤란

이러한 점들 때문에 가상 메모리가 등장했다.

### 가상 메모리
메모리를 프로세스가 직접 접근하지 않고, 가상 주소라는 주소를 사용하여 간접적으로 접근하도록 하는 방식이다.

#### 가상 메모리 응용

- 파일 맵
- 디맨드 페이징
- Copy On Write 방식의 고속 프로세스 생성
- 스왑 (Swap)
- 계층형 페이지 테이블
- Huge Page

##### Copy-on-Write
 커널은 쓰기를 요청한 프로세스를 위해 그 페이지의 복사본을 새로 만들어서 새로 만들어진 페이지에 대해 쓰기 요청을 계속 진행하게 한다. 이러한 방식을 Copy-on-Write 라고 한다. (부모 프로세스가 자식 프로세스를 `fork()` 하는 것도 같은 원리)


Copy-on-Write 방식 덕분에 프로세스들은 마치 독자적인 페이지를 가지고 있는 것 처럼 동작할 수 있다.


