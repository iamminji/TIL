### 스코프

자바스크립트에서 변수를 관리하는 메커니즘의 특징적인 부분을 3가지로 정리하면 다음과 같다.
- 변수는 함수 단위로 관리한다.
- 실행 시의 변수 검색은 렉시컬 영역을 기준으로 한다.
- 실행 시의 변수 검색은 변수 스코프 체인을 이용한다.

#### 함수 단위의 변수 관리
일반적으로는 중괄호를 사용해 변수의 영역을 결정하지만, 자바스크립트는 함수 단위다.

<pre><code>function f() {
   if (true) {
       var c=2;
   }
   return c;
}
</code></pre>

`if` 문 안에 선언이 되었음에도 `f()` 를 호출하면 __2__ 가 나온다.

만약 `var` 가 없으면 변수가 정의되는 것은 파싱 단계가 아니라 런타임이다. 그러면 c 는 전역 변수가 되는 것이다.

예제를 한 번 더 살펴보자
<pre><code>function outer() {
   var a = 1;
   console.log(a);
   
   function inner() {
       a = 2;
       console.log(a);
   }
   
   inner();
   console.log(a);
}

outer();
</code></pre>

`outer()` 를 호출하면 값은 어떻게 될까? 값은 `1,2,2` 가 된다. 함수 단위기 때문에 `inner()`의 a가 `outer`의 a도 영향을 주기 때문이다. 
`inner()` 에서 선언할 때 __var__ 키워드를 붙이면 값은 `1,2,1` 로 변한다.  

_그러므로 특별한 목적이 아니라면 변수를 선언할 때는 꼭 명시적으로 __var__ 를 붙이도록 하자!_

#### 변수 스코프 객체

변수 스코프 객체는 함수의 호출 인자, 매개변수, 그리고 파싱 후에 얻게 되는 함수 내부 변수에 대한 값을 관리하는 객체다.

아래와 같은 코드가 있을 때 출력되는 값은 어떻게 될까?
<pre><code>var g1 = "전역 변수#1";      
function f() {
   g2 = "전역 변수#2";
}
console.log(g1);
console.log(g2);
</code></pre>

우선 g1은 그대로 출력이 되지만 g2는 출력이 되지 않는다. `f()` 가 호출 되지 않았기 때문에 g2는 defined 에러가 뜨는 것이다. 그 이유는 
함수는 런타임 시 실행되기 때문이다. 호출을 해야, 루트 객체에 g2 가 추가가 된다.

#### 렉시컬 특성

자바스크립트에서는 함수를 정의하고 있는 코드의 상황과 스코프가 관련되어 있다.

<pre><code>var x = "global";
function f() {
    console.log(x);
    var x = "local";
    console.log(x);
}
f();
<code></pre>

위 코드를 실행하면 첫 번째 출력이 global 이 나올 것으로 기대하지만 실제로는 `undefined` 가 출력된다!


1. 우선 프로그램을 실행하면 먼저 전역 레벨의 파싱이 일어난다. 이 파싱의 결과로 전역 변수 x와 함수 변수 f가 정의 된다.
2. 그런 다음 f() 를 실행하면 함수 f가 호출되고 f 레벨의 파싱이 일어난다. 이 파싱의 결과로 함수 내부에 있는 x가 함수 f의 변수 스코프 객체에 정의된다.

> 자바스크립트는 함수가 실행되고 있는 환경에서 검색하는 것이 아니라 각 문장이 정의된 함수에서 검색한다!

#### 변수 스코프 체인

> 변수 검색이 가능한 영역은 변수가 정의된 함수의 변수 스코프와 부모 함수를 포함한 조상 함수의 변수 스코프다.

<pre><code>function outer(count) {
    inner();
    function inner() {
        return count--;
    };
}
</pre></code>

여기서 `outer` 를 호출하면 `inner`도 호출 되는데, `inner` 내부에서 `outer`의 count 를 쓰고 있다. 이러면 변수 스코프 체인을 거슬러 올라가서 
`outer`에 정의된 counter에 접근할 수 있게 된다!

#### 루트 객체

루트 객체는 전역 변수 스코프 객체를 의미한다. 그래서 전역 변수 스코프의 `this` 는 루트 객체를 참조하게 된다. `this` 는 전역 변수 스코프 내에서는 
생략도 가능하다.

<pre><code>// 아래 의미 동일
var o = new this.Object()
var o = new Object()
</code></pre>

이 실행문이 정의된 함수의 변수 스코프 객체에서 Object 를 찾지 못하면 체인을 거슬러 올라가서 결국 전역 변수 스코프 객체에서 찾아서 사용한다.

전역 변수 스코프에서는 `var` 를 붙이든 안 붙이든 차이는 없다. 함수 내에서는 안 붙이면 전역 변수 스코프 변수가 되지만, 전역 변수 스코프 영역 내라면 어차피 
전역 변수 스코프 객체가 되는 것이다.
