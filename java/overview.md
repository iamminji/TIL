## 자바 객체

### JVM 메모리 구조

#### 메서드 영역 (method area)
프로그램 실행 중 어떤 클래스가 사용되면, JVM 은 해당 클래스의 클래스 파일을 읽어서 분석하여 클래스에 대한 정보를 저장하는 영역이다.
#### 힙 (heap)
인스턴스 변수가 생성되는 공간
#### 호출 스택 (call stack 또는 execution stack)
메서드의 작업에 필요한 메모리 공간을 제공한다.

### 객체지향 프로그래밍

> 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조 변수의 타입은 인스턴스의 타입과 일치해야 한다.

클래스는 `객체를 생성하기 위한 틀`이며 `클래스는 속성과 기능으로 정의되어있다`

1. `변수` 하나의 데이터를 저장할 수 있는 공간
2. `배열` 같은 종류의 여러 데이터를 하나의 집합으로 저장할 수 있는 공간
3. `구조체` 서로 관련된 여러 데이터를 종류에 관계없이 하나의 집합으로 저장할 수 있는 공간
4. `클래스` 데이터와 함수의 결합(구조체 + 함수)

#### 클래스 메서드(static 메서드) 와 인스턴스 메서드
메서드 앞에 `static`이 붙어있으면 클래스 메서드이고 붙어있지 않으면 인스턴스 메서드이다.
인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는, 즉 메서드의 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드이다.

1. 클래스를 설계할 떄, 멤버변수 중 모든 인스턴스에 공통으로 사용하는 것에 static을 붙인다.
2. 클래스 변수(static)는 인스턴스를 생성하지 않아도 사용할 수 있다.
3. 클래스 메서드(static)는 인스턴스 변수를 사용할 수 없다.
4. 메서드 내에서 인스턴스 변수를 사용하지 않는다면, static을 붙이는 것을 고려한다.

#### 클래스 멤버와 인스턴스 멤버간의 참조와 호출
인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만,
클래스 멤버가 존재하는 시점에 인스턴스 멤버가 존재하지 않을 수도 있다.

```
class TestClass {
    void instanceMethod() {}
    static void staticMethod() {}

    void instanceMethod2() {
        instanceMethod();
        staticMethod();
    }

    static void staticMethod2() {
        instanceMethod(); // error!
        staticMethod();
    }
}
```

#### 오버로딩
한 클래스 내에 같은 이름의 메서드를 여러 개 정의하는 것을 메서드 오버로딩 또는 오버로딩이라 한다.
오버로딩의 성립 조건은 다음과 같다.

- 메서드 이름이 같아야 한다.
- 매개변수의 개수 또는 타입이 달라야 한다.

#### 생성자
생성자는 인스턴스가 생성될 때 호출되는 `인스턴스 초기화 메서드` 이다. 생성자의 조건은 다음과 같다.

```
- 생성자의 이름은 클래스의 이름과 같아야 한다.
- 생성자는 리턴 값이 없다.
```

컴파일러는 default 생성자를 자동으로 추가해주기도 한다. 단, 매개변수가 있는 다른 생성자가 하나도 없을 경우에만 추가가 되고
다른 생성자가 있는 경우에 default(기본) 생성자가 없으면 컴파일 에러가 난다.

##### 생성자에서 다른 생성자 호출
생성자에서 다른 생성자를 호출할 때는 다음 두 가지 조건을 만족해야 한다.

```
- 생성자의 이름으로 클래스 이름 대신 this 를 사용한다.
- 한 생성자에서 다른 생성자를 호출할 때는 반드시 첫 줄에서만 호출이 가능하다.
```

#### 오버라이딩
조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라고 한다. 오버라이딩의 성립 조건은 다음과 같다.

자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
- 이름이 같아야 한다.
- 매개변수가 같아야 한다.
- 반환 타입이 같아야 한다.

또한 다음과 같은 예외가 있다.

1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다. (public, protected, default, private 순으로 좁다고 생각하면 됨)
2. 조상 클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.

#### 다형성
자바에서는 한 타입의 참조 변수로 여러 타입의 객체를 참조할 수 있도록 함으로써 다형성을 프로그램적으로 구현하였다.
이는 부모 클래스 타입의 참조 변수로 자식 클래스의 인스턴스를 참조할 수 있도록 하겠다는 말이다.

```
class Tv {
  ...
}
```

```
class CaptionTv extends Tv {
  ...
}
```

위의 두 클래스를 이용해서 생성할 수 있는 인스턴스는 아래와 같다.

```
Tv tv = new Tv(); // 가능
CaptionTv ctv = new CaptionTv(); // 가능
Tv tv2 = new CaptionTv(); // 가능
CaptionTv ctv2 = new Tv(); // 불가능
```

자식 타입의 참조 변수가 부모 타입의 인스턴스를 참조할 수 없는 이유는, 자식은 부모의 멤버 변수(혹은 메서드) 의 수 보다 크거나
같은데, 자식 타입으로 참조 변수를 생성하면 접근가능한 멤버 변수(혹은 메서드)는 부모 타입에 없으므로 컴파일 에러가 나는 것이다.

> 부모의 참조 변수로 자식타입의 인스턴스를 참조할 수 있다. 반대로 자식타입의 참조 변수로 부모 타입의 인스턴스를 참조할 수는 없다.

형변환도 마찬가지다.

```
자식 타입 -> 부모 타입 (Up-casting)   : 형 변환 생략 가능
자식 타입 <- 부모 타입 (Down-casting) : 형 변환 생략 불가
```

#### 추상 클래스
추상 클래스는 키워드 `abstract` 를 붙이기만 하면 된다. 추상 메서드를 포함하고 있지 않아도 키워드 `abstract` 는 붙일 수 있다. 이 경우 역시 인스턴스 생성은 불가능하다.
