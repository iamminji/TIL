# 자바 8 인 액션


#### 동작 파라미터화
동작 파라미터화 _behavior parameterization_ 을 이용하면 자주 바뀌는 요구사항에 효과적으로 대응할 수 있다. 동작 파라미터화란 아직은 어떻게 실행할 것인지 결정하지 않은 코드 블록을 의미한다.

> strategy design pattern 전략 디자인 패턴은 각 알고리즘을을 캡슐화 하는 알고리즘 패밀리를 정의해둔 다음에 런타임에 알고리즘을 선택하는 기법이다.

## 람다
람다는 아래와 같은 특징을 갖는다.

```
(파라미터, ...) -> 람다 바디
```
위와 같은 형태로 구현되며, 아래의 예제 처럼 사용한다.

```
(String s) -> s.length
(Apple a) -> a.getWeight() > 150
(int x, int y) -> { System.out.println(x+y); }
() -> 42
(Apple a1, Apple a2) -> a1.getWeight().compareTo(a2.getWeight())
```

##### 익명
보통의 메서드와 달리 이름이 없으므로 익명이라 표현한다.
##### 함수
람다는 메서드처럼 특정 클래스에 종속되지 않으므로 함수라 부른다. ㅏ지만 메서드처럼 파라미터 리스트, 바디, 반환 형식, 가능한 예외 리스트를 포함한다.
##### 전달
람다 표현식을 메서드 인수로 전달하거나 변수로 저장할 수 있다.
##### 간결성
익명 클래스처럼 많은 자질구레한 코드를 구현할 필요가 없다.

#### 지역 변수
람다 표현식에서는 익명 함수가 하는 것 처럼 __자유 변수__ free variable (파라미터로 넘겨진 변수가 아닌 외부에서 정의된 변수) 를 활용할 수 있다. 이와 같은 동작을 __람다 캡처링__ 이라고 부른다

```
int portNumber = 6879;
Runnable r = () -> System.out.println(portNumber);
portNumber = 9999;
```

단, 위와 같은 형태로는 사용할 수 없다. 그 이유는 자유 변수가 __final__ 로 정의되어 있지 않기 때문이다. 이 의미는 반드시 람다에서 활용하는 외부 변수(자유 변수) 는 __final__ 로 정의되거나 실질적으로 __final__ 로 선언된 변수와 똑같이 사용되어야 한다는 것이다.

> 인스턴스 변수는 힙에 저장되고, 지역 변수는 스택에 저장된다. 그렇기에 스레드에서 자유 변수를 사용하고 람다로 스레드를 쓴다고 했을 때, 변수를 할당한 스레드가 사라져 버려 변수 할당이 해제되었음에도 람다를 실행하는 스레드에서 해당 변수를 접근하려고 할 수 있다. 그래서 자바에선 자유 변수의 복사본을 제공하여 활용하게 하고 이 변수의 값이 변경되면 안 되기 때문에 __final__ 로 명시하는 것이다.

#### 메서드 레퍼런스
메서드 레퍼런스는 `::` 를 메서드 명 앞에 붙임으로 써 사용할 수 있다.

example

| 람다 | 메서드 레퍼런스 단축 표현 |
| ---| ----|
|(Apple a) -> a.getWeight() | Apple::getWeight|
|(String s) -> System.out.println(s) | System.out::println(s)|


### 함수형 인터페이스
오직 하나의 추상 메서드만을 갖는 인터페이스를 함수형 인터페이스라고 한다.

> 람다 표현식으로 함수형 인터페이스의 추상 메서드 구현을 직접 전달할 수 있으므로 전체 표현식을 함수형 인터페이스의 인스턴스로 취급할 수 있다.

#### Predicate
`java.util.function.Predicate<T>` 인터페이스는 `test` 라는 추상 메서드를 정의하며 `test` 는 제네릭 형식 T 의 객체를 인수로 받아 불린을 반환한다.

#### Consumer
`java.util.function.Consumer<T>` 인터페이스는 제네릭 형식 T 객체를 받아서 `void` 를 반환하는 `accept` 라는 추상 메서드를 정의한다.

T 형식의 객체를 인수로 받아서 어떤 동작을 수행하고 싶을 때 사용하면 된다.

#### Function
`java.util.function.Function<T, R>` 인터페이스는 제네릭 형식 T 를 인수로 받아서 제네릭 형식 R 객체를 반환하는 `apply` 라는 추상 메서드를 정의한다.

입력을 출력으로 매핑하는 람다를 정의할 때 활용할 수 있다.

## 스트림
스트림이란 _데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소_ 를 의미한다.

#### 연속된 요소
컬렉션과 마찬가지로 스트림은 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공한다. 단, 컬렉션의 주제는 데이터고 스트림의 주제는 계산이다.

#### 소스
스트림은 컬렉션, 배열, I/O 자원등의 데이터 제공 소스로부터 데이터를 소비한다.

#### 데이터 처리 연산
스트림에는 `filter`, `map`, `reduce`, `match`, `sort` 등으로 부터 데이터를 조작할 수 있다.

#### 파이프라이닝

#### 내부 반복

### 중간 연산
`filter` 나 `sorted` 같은 중간 연산은 다른 스트림을 반환한다. 따라서 여러 중간 연산을 연결해서 질의를 만들 수 있다. 중간 연산의 중요한 특징은 단말 연산을 스트림 파이프라인에 실행하기 전 까지는 아무 연산도 수행하지 않는다는 것이다. (lazy!)

### 최종 연산
최종 연산은 스트림 파이프라인에서 결과를 도출한다. 보통 최종 연산에 의해 `List`, `Integer`, `void` 등 스트림 이외의 결과가 반환 된다.
