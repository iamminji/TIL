
unit22. 슬라이스 사용하기
==
  
  
슬라이스는 배열과 같지만, 길이가 고정되어 있지 않으며 동적으로 크기가 늘어난다. 또한, 배열과는 달리 레퍼런스 타입이다.
  
+ var 슬라이스명 []자료형
  
<pre><code>var a []int
</code></pre>
  
이렇게 생성된 슬라이스의 길이는 0 이다.
  
슬라이스는 __make__ 함수를 사용하여 공간을 할당해야 값을 넣을 수 있다.
  
+ make([]자료형, 길이)
  
슬라이스를 생성하면서 값을 초기화 하려면 __{}__ 중괄호를 사용한다. 중괄호 안의 값은 한 줄도 가능하고 여러 줄도 된다. 대신 배열 처럼 여러 줄 나열할 경우엔 
가장 마지막 요소에 콤바를 붙여준다. 
슬라이스므로 대괄호에는 길이를 설정하지 않는다.
  
실제로 슬라이스는 배열을 내장하고 있는데, 이 배열이 더 늘어났을 때 사용할 공간을 미리 할당할 수 있다.
  
+ make([]자료형, 길이, 용량)
  
<pre><code>var s = make([]int, 5, 10)
</code></pre>
  
이렇게 생성하면 길이(length)가 5이며 용량(capacity)이 10인 슬라이스가 생성된다. 여기서 슬라이스 길이는 용량보다 크게 설정할 수 없다. 
또한 용량을 생략하면 용량은 길이와 동일하게 설정 된다.
  
+ 길이 (length)
    = 인덱스로 접근할 수 있는 공간 / 슬라이스 내부 배열의 최대 길이. 용량이 더 확보되어 있더라도 길이 이상의 인덱스에 접근하면 런타임 에러가 발생한다.
+ 용량 (capacity)
    = 실제 메모리에 할당된 공간. 만약 슬라이스에 요소를 추가하여 용량이 가득차면 용량은 자동으로 늘어난다.

미리 용량을 크게 하면 요소가 추가될 때마다 메모리를 새로 할당하지 않아도 되므로 성능상 이점이 있다. 하지만, 처음부터 메모리 공간을 많이 차지한다. 반대로
 슬라이스 용량을 적게 할당하면 요소가 추가될 때마다 메모리를 새로 할당하게 되므로 성능이 떨어질 수 있다.
  
슬라이스 길이는 __len__ 함수로 구하고 용량은 __cap__ 함수로 구할 수 있다.
  
22.1 슬라이스에 값 추가하기
--
append 함수를 사용하면 슬라이스의 맨 뒤에 값을 추가할 수 있다.
  
+ append(슬라이스, 값1, 값2, 값3)
+ append(슬라이스1, 슬라이스2...)
    = 슬라이스1 뒤에 슬라이스2 붙이기
  
22.2 레퍼런스 타입
--
슬라이스는 레퍼런스 타입이다. 내장된 배열에 대한 포인터이므로 슬라이스끼리 대입하면 값이 복사되지 않고 참조만 한다.
  
##### 배열의 복사
<pre><code>a := [3]int{1, 2, 3}
var b [3]int

b = a // 배열의 요소가 모두 복사됨
b[0] = 9 // b[0]에 9를 대입하면 b의 첫 번째 요소만 바뀜

fmt.Println(a) // [1 2 3]
fmt.Println(b) // [9 2 3]
</code></pre>
  
##### 슬라이스의 복사
<pre><code>a := []int{1, 2, 3}
var b []int // 슬라이스로 선언

b = a // a를 b에 대입해도 요소가 모두 복사되지 않고 참조만 함
b[0] = 9 // 슬라이스는 참조이므로 a[0], b[0]의 값이 모두 바뀜

fmt.Println(a) [9 2 3]
fmt.Println(b) [9 2 3]
</code></pre>
  
22.3 슬라이스 복사하기
--
슬라이스의 요소를 모두 복사할 때는 <code>copy</code> 함수를 사용한다.
  
+ copy(복사될 슬라이스, 원본 슬라이스)
  
공간을 할당하지 않은 빈 슬라이스에는 요소를 복사할 수 없다.
  
슬라이스를 복사하였으므로 복사된 슬라이스의 요소를 바꾸어도 원본 슬라이스는 바뀌지 않는다.
  
22.4 슬라이스와 용량
--
<pre><code>a := []int{1, 2, 3, 4, 5}
fmt.Println(len(a), cap(a))
a = append(a, 6, 7)
fmt.Println(len(a), cap(a))
</code></pre>
  
결과 값
<pre><code>5 5
7 10
</code></pre>
  
처음에는 슬라이스 a의 길이와 용량 모두 5 이다. 값 2개를 추가 하고 나자 길이는 7이 되고 용량은 10으로 늘어났다. 
이처럼 Go 언어는 동적 배열을 구현하기 위해 길이와 용량을 구분하고 있다. 
따라서 슬라이스의 요소가 늘어나면 Go 런타임은 정해진 알고리즘에 의해 슬라이스의 용량을 늘린다.
  
22.5 부분 슬라이스 만들기
--
슬라이스는 기존 슬라이스에서 일정 위치를 지정하여 부분 슬라이스를 만들 수 있다.
  
+ 슬라이스[시작_인덱스:끝_인덱스]
  
<pre><code>a := []int{1 ,2 ,3 ,4 ,5}
b := a[0:5]
</code></pre>
  
a의 부분 슬라이스 b를 위의 코드처럼 만들었다. 그러나 이는 복사가 아니므로 (슬라이스는 모다?! 레퍼런스다!) 값의 요소를 바꾸면 기존 슬라이스도 변경이 된다.
  
슬라이스는 파이썬의 리스트 처럼 시작 인덱스와 끝 인덱스를 생략할 수 있다. 생략하면 시작 인덱스는 0이고 끝 인덱스는 슬라이스의 길이다.
  
배열도 부분 슬라이스를 만들 수 있다. 생성할 때 배열의 길이만 넣으면 된다. 하지만 이 역시 슬라이스이기 때문에 값 변경 시 기존 배열 값도 변경이 된다.
  
부분 슬라이스를 만들면서 용량도 지정할 수 있다.
  
+ 슬라이스[시작_인덱스:끝_인덱스:용량]
  
단, 용량을 설정할 때 기존 슬라이스의 용량을 넘을 수는 없다.
